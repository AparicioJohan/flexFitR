% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/02_modeler.R
\name{modeler}
\alias{modeler}
\title{Modeler}
\usage{
modeler(
  data,
  x,
  y,
  grp,
  keep,
  fn = "fn_piwise",
  parameters = NULL,
  lower = -Inf,
  upper = Inf,
  fixed_params = NULL,
  method = c("subplex", "pracmanm", "anms"),
  subset = NULL,
  options = modeler.options(),
  control = list()
)
}
\arguments{
\item{data}{A data.frame in a wide format.}

\item{x}{The name of the column in `data` that contains x points.}

\item{y}{The name of the column in `data` that contain the variable to be analyzed. Must match a var in the data.}

\item{grp}{The names of the columns in `data` that contains a grouping variable. (Optional).}

\item{keep}{The names of the columns in `data` to keep across the analysis.}

\item{fn}{A string specifying the name of the function to be used for the curve fitting. Default is \code{"fn_piwise"}.}

\item{parameters}{Can be a named numeric vector specifying the initial values for the parameters to be optimized,
or a data frame with columns \code{uid}, and the initial parameter values for each group id. Used for providing specific
initial values per group id. Default is \code{NULL}.}

\item{lower}{Numeric vector specifying the lower bounds for the parameters. Default is \code{-Inf} for all parameters.}

\item{upper}{Numeric vector specifying the upper bounds for the parameters. Default is \code{Inf} for all parameters.}

\item{fixed_params}{A data frame with columns \code{uid}, and the fixed parameter values for each group id. Used for fixing certain parameters during optimization.}

\item{method}{A character vector specifying the optimization methods to be used. Check `optimx::checkallsolvers()` for available methods.
Default is \code{c("subplex", "pracmanm", "anms")}.}

\item{subset}{An optional vector with levels of `grp` to filter the data. Default is \code{NULL}, meaning all groups are used.}

\item{options}{A list of additional options. See `modeler.options()`
\describe{
  \item{\code{add_zero}}{Logical. If \code{TRUE}, adds a zero value to the series at the start. Default is \code{FALSE}.}
  \item{\code{check_negative}}{Logical. If \code{TRUE}, converts negative values in the data to zero. Default is \code{FALSE}.}
  \item{\code{max_as_last}}{Logical. If \code{TRUE}, appends the maximum value after reaching the maximum. Default is \code{FALSE}.}
  \item{\code{progress}}{Logical. If \code{TRUE} a progress bar is displayed. Default is \code{FALSE}. Try this before running the function: \code{progressr::handlers("progress", "beepr")}.}
  \item{\code{parallel}}{Logical. If \code{TRUE} the model fit is performed in parallel. Default is \code{FALSE}.}
  \item{\code{workers}}{The number of parallel processes to use. `parallel::detectCores()`}
  \item{\code{trace}}{If \code{TRUE} , convergence monitoring of the current fit is reported in the console. \code{FALSE} by default.}
  \item{\code{return_method}}{ Logical. If \code{TRUE}, includes the optimization method used in the result. Default is \code{FALSE}.}
}}

\item{control}{A list of control parameters to be passed to the optimization function. For example: \code{list(maxit = 500)}.}
}
\value{
An object of class \code{modeler}, which is a list containing the following elements:
\describe{
  \item{\code{param}}{A data frame containing the optimized parameters and related information.}
  \item{\code{dt}}{A data frame with data used and fitted values.}
  \item{\code{fn}}{The call used when fitting models.}
  \item{\code{metrics}}{Metrics and summary of the models.}
  \item{\code{execution}}{Execution time.}
  \item{\code{response}}{Response variable.}
  \item{\code{keep}}{Metadata to keep across.}
  \item{\code{fun}}{Name of the function.}
  \item{\code{parallel}}{List returning parallel and workers.}
  \item{\code{fit}}{List with the fitted models.}
}
}
\description{
General-purpose optimization techniques for non-linear least squares problems.
}
\examples{
library(flexFitR)
data(dt_potato_20)
explorer <- explorer(dt_potato_20, x = DAP, y = c(Canopy, GLI_2), id = Plot)
# Example 1
mod_1 <- dt_potato_20 |>
  modeler(
    x = DAP,
    y = GLI_2,
    grp = Plot,
    fn = "fn_lin_pl_lin",
    parameters = c(t1 = 38.7, t2 = 62, t3 = 90, k = 0.32, beta = -0.01),
    subset = 195,
    options = list(add_zero = TRUE)
  )
plot(mod_1, id = 195)
print(mod_1)
# Example 2
mod_2 <- dt_potato_20 |>
  modeler(
    x = DAP,
    y = Canopy,
    grp = Plot,
    fn = "fn_piwise",
    parameters = c(t1 = 45, t2 = 80, k = 0.9),
    subset = 195,
    options = list(add_zero = TRUE, max_as_last = TRUE)
  )
plot(mod_2, id = 195)
print(mod_2)
}
